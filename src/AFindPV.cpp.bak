/*
 * @file AFindPV.cpp 查找位置变化的瞬变源
 */
#include "ADefine.h"
#include "AFindPV.h"

namespace AstroUtil {
///////////////////////////////////////////////////////////////////////////////
AFindPV::AFindPV() {
	fno_ = -1;
}

AFindPV::~AFindPV() {
	objs_.clear();
}

bool AFindPV::is_star(PPVPT pt) {
	for (PPVPTVEC::iterator it = stars_.begin(); it != stars_.end(); ++it) { // 优先比较stars_
		if (is_same(pt, *it)) {
			(*it)->x = pt->x;
			(*it)->y = pt->y;
			++(*it)->lmatch;
			return true;
		}
	}

	if (frmprev_.use_count()) {
		PPVPTVEC &prev = frmprev_->pts;
		for (PPVPTVEC::iterator it = prev.begin(); it != prev.end(); ++it) { // 将帧数据转移至stars_
			if (is_same(pt, *it)) {
				(*it)->x = pt->x;
				(*it)->y = pt->y;
				++(*it)->lmatch;
				stars_.push_back(*it);
				prev.erase(it);
				return true;
			}
		}
	}

	return false;
}

bool AFindPV::is_same(PPVPT pt1, PPVPT pt2) {
	double ex = pt1->x - pt2->x;
	double ey = pt1->y - pt2->y;
	return (fabs(ex) < 2.0 && fabs(ey) < 2.0);
}

void AFindPV::NewSequence() {
	fno_ = -1;
	objs_.clear();
}

void AFindPV::EndSequence() {
	if (fno_ != -1) {
		recheck_candidates();	// 检查候选体的有效性
		append_candidates(); 	// 尝试将该帧数据加入候选体
		complete_candidates();	// 将所有候选体转换为目标
	}
	stars_.clear();
	cans_.clear();
	frmprev_.reset();
	frmlast_.reset();
}

void AFindPV::AddPoint(PPVPT pt) {
	if (fno_ != pt->fno) {
		if (fno_ != -1)
			end_frame();
		new_frame(pt->mjd);
		fno_ = pt->fno;
	}
	if (!is_star(pt))
		frmlast_->pts.push_back(pt);
}

/*!
 * @brief 查看候选体
 */
PPVCANVEC& AFindPV::GetCandidate() {
	return cans_;
}

/*!
 * @brief 查看被识别的目标数量
 */
int AFindPV::GetNumber() {
	return objs_.size();
}

/*!
 * @brief 查看被识别的目标
 */
PPVOBJVEC& AFindPV::GetObject() {
	return objs_;
}

void AFindPV::new_frame(double mjd) {
	frmprev_ = frmlast_;
	frmlast_ = boost::make_shared<PVFRM>(mjd);
}

void AFindPV::end_frame() {
	recheck_candidates();	// 检查候选体的有效性, 释放无效候选体
	append_candidates(); 	// 尝试将该帧数据加入候选体
	create_candidates();	// 为未关联数据建立新的候选体

	for (PPVPTVEC::iterator it = stars_.begin(); it != stars_.end();) {
		if ((*it)->lmatch) {
			++(*it)->tmatch;
			(*it)->lmatch = 0;
			++it;
		}
		else if (--(*it)->tmatch < 0)
			it = stars_.erase(it);
		else
			++it;
	}
//	printf("candidates : %5d, stars : %5d, frame : %5d\n", cans_.size(),
//			stars_.size(), frmlast_->pts.size());
}

void AFindPV::create_candidates() {
	if (!(frmprev_.unique() && frmlast_.unique()))
		return;

	PPVPTVEC &pts1 = frmprev_->pts;
	PPVPTVEC &pts2 = frmlast_->pts;
	double stepmin = param_.stepmin;
	double stepmax = param_.stepmax;
	double dx, dy;
	// 由相邻帧未关联数据构建候选体
	for (PPVPTVEC::iterator it1 = pts1.begin(); it1 != pts1.end(); ++it1) {
		for (PPVPTVEC::iterator it2 = pts2.begin(); it2 != pts2.end(); ++it2) {
			dx = fabs((*it2)->x - (*it1)->x);
			dy = fabs((*it2)->y - (*it1)->y);

			if (stepmin <= dx && dx <= stepmax && stepmin <= dy
					&& dy <= stepmax) {
				PPVCAN can = boost::make_shared<PVCAN>();
				can->add_point(*it1);
				can->add_point(*it2);
				cans_.push_back(can);
			}
		}
	}
}

void AFindPV::append_candidates() {
	if (!cans_.size())
		return; // 无候选体立即返回

	double stepmin = param_.stepmin;
	double stepmax = param_.stepmax;
	double dxy = param_.dxymax;
	double mjd = frmlast_->mjd;
	double x1, y1, x2, y2, dx1, dy1, dx2, dy2;
	PPVPTVEC &pts = frmlast_->pts;
	PPVPT pt;
	PPVCAN can;

	// 1. 尝试将帧数据追加至候选体
	for (PPVCANVEC::iterator it = cans_.begin(); it != cans_.end(); ++it) {
		can = *it;
		// 候选体最后一个点的坐标
		pt = can->last_point();
		x1 = pt->x;
		y1 = pt->y;
		for (PPVPTVEC::iterator i = pts.begin(); i != pts.end(); ++i) { // 与当前帧数据交叉比对
			dx1 = fabs(x1 - (*i)->x);
			dy1 = fabs(y1 - (*i)->y);
			if (stepmin <= dx1 && dx1 <= stepmax && stepmin <= dy1
					&& dy1 <= stepmax) { // 位置变化步长未超出阈值
				if (can->xy_expect(mjd, x2, y2)) { // 预测位置与测量位置偏差未超出阈值
					dx2 = fabs(x2 - (*i)->x);
					dy2 = fabs(y2 - (*i)->y);
					if (dx2 <= dxy && dy2 <= dxy) {
						can->add_point(*i);
					}
				} else {
					can->add_point(*i);
				}
			}
		}
	}
	// 2. 将确定帧数据加入候选体
	for (PPVCANVEC::iterator it = cans_.begin(); it != cans_.end(); ++it) {
		pt = (*it)->update();

		if (pt.use_count()) { // 通知数据库, 构成弧段的数据点
			if ((*it)->pts.size() == 3) { // 通知数据库, 构成弧段的前两个数据点

			}
		}
	}
	// 3. 剔除已加入候选体的数据点
	for (PPVPTVEC::iterator it = pts.begin(); it != pts.end();) {
		if ((*it)->related)
			it = pts.erase(it);
		else
			++it;
	}
	if (!pts.size())
		frmlast_.reset();
}

/*
 * 检查候选体的有效性, 判据: 时标偏差
 * - 大于阈值, 1. 数据点多于阈值, 转换为目标; 2. 数据点小于阈值, 剔除
 * - 小于阈值, 保留
 */
void AFindPV::recheck_candidates() {
	if (cans_.size()) {
		int nptmin = param_.nptmin;
		double dtmax = param_.dtmax;
		double mjd = frmlast_->mjd;
		double dt;

		for (PPVCANVEC::iterator it = cans_.begin(); it != cans_.end();) {
			dt = mjd - (*it)->lastmjd;
			if (0 < dt && dt <= dtmax && ((*it)->fx || (*it)->fy))
				++it; // 保留. dt > 0: 原始数据未按时间严格排序
			else { // 移出候选体集合
				if ((*it)->pts.size() >= nptmin)
					candidate2object(*it); // 转换为目标
				it = cans_.erase(it);
			}
		}
	}
}

void AFindPV::complete_candidates() {
	int nptmin = param_.nptmin;

	for (PPVCANVEC::iterator it = cans_.begin(); it != cans_.end(); ++it) {
		if ((*it)->pts.size() >= nptmin)
			candidate2object(*it);
	}
}

void AFindPV::candidate2object(PPVCAN can) {
	PPVPTVEC & pts = can->pts;
	PPVOBJ obj = boost::make_shared<PVOBJ>();
	PPVPTVEC &npts = obj->pts;

	for (PPVPTVEC::iterator it = pts.begin(); it != pts.end(); ++it) {
		npts.push_back(*it);
	}
	objs_.push_back(obj);
}

///////////////////////////////////////////////////////////////////////////////
} /* namespace AstroUtil */
